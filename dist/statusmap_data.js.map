{"version":3,"sources":["../src/statusmap_data.ts"],"names":["Bucket","ts","from","to","value","values","push","length","BucketMatrix","yid","xid","buckets","hasData","targets","map","target","pagerChanged","name","BucketMatrixPager","m","bucketMatrix","enable","slice","pageSize","currentPage","me","rowLabel","num","defaultPageSize","Math","ceil","totalRows","last","hasNext","hasPrev"],"mappings":"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","sourcesContent":["// A holder of a group of values\nclass Bucket {\n  // uniq id\n  id: number = 0;\n  // Array of values in this bucket\n  values: any[] = [];\n  columns: any[] = []; // From pr/86\n  // a bucket has multiple values\n  multipleValues: boolean = false;\n  // a bucket has values that has no mapped color\n  noColorDefined: boolean = false;\n  // y label\n  y: string = \"\";\n  yLabel: string = \"\";\n  pLabels: string[] = [];\n\n  // This value can be used to calculate a x coordinate on a graph\n  x: number = 0;\n  xid: number = 0;\n  // a time range of this bucket\n  from: number = 0;\n  to: number = 0;\n  // to and from relative to real \"from\"\n  relFrom: number = 0;\n  relTo: number = 0;\n\n  mostRecent: boolean = false;\n\n  // Saved minimum and maximum of values in this bucket\n  minValue: number = 0;\n  maxValue: number = 0;\n  // A value if multiple values is not allowed\n  value: number = 0;\n\n  constructor() {\n  }\n\n  belong(ts: number): boolean {\n    return ts >= this.from && ts <= this.to;\n  }\n\n  put(value: any) {\n    this.values.push(value);\n  }\n\n  done() {\n    // calculate min, max, value\n  }\n\n  isEmpty(): boolean {\n    return this.values.length == 0;\n  }\n\n}\n\n\nclass BucketMatrix {\n  // buckets for each y label\n  buckets: {[yLabel: string]: Bucket[]} = {};\n  maxValue: number = 0;\n  minValue: number = 0;\n  multipleValues: boolean = false;\n  noColorDefined: boolean = false;\n  // a flag that indicate that buckets has stub values\n  noDatapoints: boolean = false;\n\n  // An array of row labels\n  targets: string[] = [];\n  pLabels: {[target: string]: string[]} = {};\n  rangeMs: number = 0;\n  intervalMs: number = 0;\n\n  xBucketSize: number = 0; // TODO remove: a transition from CardsData\n\n  constructor() {\n  }\n\n  get(yid: string, xid: number): Bucket {\n    if (yid in this.buckets) {\n      if (xid in this.buckets[yid]) {\n        return this.buckets[yid][xid];\n      }\n    }\n    return new Bucket();\n  }\n\n  hasData(): boolean {\n    let hasData = false;\n    if (this.targets.length > 0) {\n      this.targets.map((target:string) => {\n        if (this.buckets[target].length > 0) {\n          hasData = true;\n        }\n      });\n    }\n    return hasData;\n  }\n}\n\nexport var pagerChanged:any = {name:'statusmap-pager-changed'};\n\nclass BucketMatrixPager {\n  bucketMatrix: BucketMatrix;\n  enable: boolean;\n  defaultPageSize: number = -1;\n  pageSize: number = -1;\n  currentPage: number = 0;\n\n  constructor() {\n    let m = new BucketMatrix();\n\n    this.bucketMatrix = m;\n  }\n\n  // An array of row labels for current page.\n  targets(): string[] {\n    if (!this.enable) {\n      return this.bucketMatrix.targets;\n    }\n\n    return this.bucketMatrix.targets.slice(this.pageSize * this.currentPage, this.pageSize * (this.currentPage+1) );\n  }\n\n  buckets(): {[yLabel: string]: Bucket[]} {\n    if (!this.enable) {\n      return this.bucketMatrix.buckets;\n    }\n\n    let buckets: {[yLabel: string]: Bucket[]} = {}\n    let me = this;\n\n    this.targets().map(function (rowLabel) {\n      buckets[rowLabel] = me.bucketMatrix.buckets[rowLabel];\n    })\n\n    return buckets;\n  }\n\n  setEnable(enable: boolean) {\n    this.enable = enable;\n  }\n\n  setCurrent(num: number): void {\n    this.currentPage = num;\n  }\n\n  setDefaultPageSize(num: number): void {\n    this.defaultPageSize = num;\n  }\n\n  setPageSize(num: number): void {\n    this.pageSize = num;\n  }\n\n  pages(): number {\n    return Math.ceil(this.totalRows() / this.pageSize);\n  }\n\n  totalRows(): number {\n    return this.bucketMatrix.targets.length;\n  }\n\n  pageStartRow(): number {\n    if (!this.enable) {\n      return 1;\n    }\n    return (this.pageSize * this.currentPage) + 1;\n  }\n\n  pageEndRow(): number {\n    if (!this.enable) {\n      return this.totalRows();\n    }\n\n    let last = this.pageSize * (this.currentPage+1);\n    if (last > this.totalRows()) {\n      return this.totalRows();\n    }\n\n    return last;\n  }\n\n  hasNext(): boolean {\n    if (!this.enable) {\n      return false;\n    }\n\n    if ((this.currentPage+1)*this.pageSize >= this.totalRows()) {\n      return false;\n    }\n\n    return true;\n    // currentPage >= ctrl.bucketMatrix.targets.length/ctrl.pageSizeViewer - 1 || ctrl.numberOfPages == 0\n  }\n\n  hasPrev(): boolean {\n    if (!this.enable) {\n      return false;\n    }\n\n    return this.currentPage > 0;\n  }\n\n  switchToNext() {\n    if (this.hasNext()) {\n      this.currentPage = this.currentPage + 1;\n    }\n  }\n\n  switchToPrev() {\n    if (this.hasPrev()) {\n      this.currentPage = this.currentPage - 1;\n    }\n  }\n\n}\n\nexport {Bucket, BucketMatrix, BucketMatrixPager };"],"file":"statusmap_data.js"}